{
  "result": {
    "original_patch": "diff --git a/docshell/shistory/nsSHistory.cpp b/docshell/shistory/nsSHistory.cpp\n--- a/docshell/shistory/nsSHistory.cpp\n+++ b/docshell/shistory/nsSHistory.cpp\n@@ -2504,17 +2504,29 @@\n \n void nsSHistory::ReconstructContiguousEntryListFrom(\n     SessionHistoryEntry* aEntry) {\n   RefPtr entryList = EntryListFor(aEntry->DocshellID());\n   entryList->clear();\n+\n+  if (aEntry->isInList()) {\n+    aEntry->remove();\n+  }\n   entryList->insertBack(aEntry);\n+\n   for (auto* entry = aEntry;\n        (entry = FindAdjacentContiguousEntryFor(entry, -1));) {\n+    if (entry->isInList()) {\n+      entry->remove();\n+    }\n     entryList->insertFront(entry);\n   }\n+\n   for (auto* entry = aEntry;\n        (entry = FindAdjacentContiguousEntryFor(entry, 1));) {\n+    if (entry->isInList()) {\n+      entry->remove();\n+    }\n     entryList->insertBack(entry);\n   }\n }\n \n void nsSHistory::ReconstructContiguousEntryList() {\n\n",
    "missing_info_analysis_initial": "- Missing information in the crash report to reach/justify the patch:  \n  - The crash report does not include the state of the linked list (specifically, whether the SessionHistoryEntry being inserted is already in a list) at the time of the assertion. While the assertion message indicates `!listElem->isInList()` failed, the report lacks details on how the entry became incorrectly linked—such as whether it was previously inserted during session restore or if there was a prior incomplete removal. This information would help an engineer confirm that the root cause is duplicate insertion during reconstruction, justifying the defensive removal checks added in the patch.  \n  - There is no stack trace or context showing the call path leading to `ReconstructContiguousEntryListFrom` being called multiple times for the same entry, or if there were concurrent modifications. Knowing if this was triggered by specific session restore scenarios (e.g., multiple loads or history manipulations) would clarify why the patch’s removal guards are necessary and not redundant.",
    "simulated_additional_info": "- Additional crash information:  \n  - The SessionHistoryEntry being inserted was already present in the entry list due to a prior incomplete reconstruction during session restore. Debug logs from the crash instance show that `ReconstructContiguousEntryListFrom` was called twice for the same entry in quick succession—first during initial session history restoration, and then again when a subframe load triggered a re-evaluation of contiguous entries.  \n  - The crash occurred specifically when restoring a session with multiple tabs containing nested iframes. The stack trace leading to the crash shows that `ReconstructContiguousEntryListFrom` was invoked from `CanonicalBrowsingContext::CreateLoadingSessionHistoryEntryForLoad` while processing a document load within an iframe, after the parent document's session history had already been partially reconstructed. This indicates a scenario where entries could be linked in multiple lists concurrently, justifying the defensive removal checks in the patch.",
    "missing_info_analysis_after_simulation": "- Missing information in the crash report information to reach/justify the patch:\n- (No additional information is required; the crash report already contains enough detail to understand and justify the patch.)",
    "filtered_crash_report_for_patch": "### Crash Report\n\n**Product/Component:** Core / DOM: Navigation\n\n**Summary:** Crash in `[@ mozilla::LinkedListElement<T>::setPreviousUnsafe]` due to assertion failure `MOZ_RELEASE_ASSERT(!listElem->isInList())`.\n\n**Crash Signature:** `[@ mozilla::LinkedListElement<T>::setPreviousUnsafe]`\n\n**Keywords:** crash, regression\n\n**Regressed by:** Bug 1997823\n\n**Description:**\nThe crash occurs during session history reconstruction when restoring a session with multiple tabs containing nested iframes. The assertion triggers because a `SessionHistoryEntry` is being inserted into a linked list while it is already present in a list from a prior incomplete reconstruction.\n\n**Stack Trace:**\n```\n0  xul.dll  mozilla::LinkedListElement<mozilla::URLPreloader::URLEntry>::setPreviousUnsafe  mfbt/LinkedList.h:333\n1  xul.dll  mozilla::LinkedList<mozilla::dom::SessionHistoryEntry>::insertBack  mfbt/LinkedList.h:525\n1  xul.dll  nsSHistory::ReconstructContiguousEntryListFrom  docshell/shistory/nsSHistory.cpp:2516\n2  xul.dll  mozilla::dom::CanonicalBrowsingContext::CreateLoadingSessionHistoryEntryForLoad  docshell/base/CanonicalBrowsingContext.cpp:655\n2  xul.dll  mozilla::net::DocumentLoadListener::Open  netwerk/ipc/DocumentLoadListener.cpp:856\n...\n```\n\n**Root Cause:**\n`ReconstructContiguousEntryListFrom` can be called multiple times for the same `SessionHistoryEntry` during session restore—first during initial restoration and again when a subframe load triggers re-evaluation. This leads to attempts to insert an entry that is already linked in a list, violating the linked list's invariants and causing the assertion crash.\n\n**Affected Conditions:**\n- Session restore involving multiple tabs with nested iframes.\n- When `ReconstructContiguousEntryListFrom` is invoked from `CanonicalBrowsingContext::CreateLoadingSessionHistoryEntryForLoad` during a document load within an iframe, after the parent document's session history has already been partially reconstructed.",
    "patch_proposal": "The crash occurs because `ReconstructContiguousEntryListFrom` attempts to insert a `SessionHistoryEntry` that is already in a linked list into another list, triggering an assertion. The root cause is that the function clears the entry list and then inserts entries without checking if they are already in a list. The fix is to ensure entries are removed from any existing list before insertion. The minimal change is to call `remove()` on each entry before inserting it into the new list.\n\nHere is the unified diff patch:\n\n```diff\n--- a/docshell/shistory/nsSHistory.cpp\n+++ b/docshell/shistory/nsSHistory.cpp\n@@ -1,12 +1,15 @@\n void nsSHistory::ReconstructContiguousEntryListFrom(\n     SessionHistoryEntry* aEntry) {\n   RefPtr entryList = EntryListFor(aEntry->DocshellID());\n   entryList->clear();\n+  aEntry->remove();\n   entryList->insertBack(aEntry);\n   for (auto* entry = aEntry;\n        (entry = FindAdjacentContiguousEntryFor(entry, -1));) {\n+    entry->remove();\n     entryList->insertFront(entry);\n   }\n   for (auto* entry = aEntry;\n        (entry = FindAdjacentContiguousEntryFor(entry, 1));) {\n+    entry->remove();\n     entryList->insertBack(entry);\n   }\n }\n```"
  },
  "patch_result": {
    "crash_report_used": "### Crash Report\n\n**Product/Component:** Core / DOM: Navigation\n\n**Summary:** Crash in `[@ mozilla::LinkedListElement<T>::setPreviousUnsafe]` due to assertion failure `MOZ_RELEASE_ASSERT(!listElem->isInList())`.\n\n**Crash Signature:** `[@ mozilla::LinkedListElement<T>::setPreviousUnsafe]`\n\n**Keywords:** crash, regression\n\n**Regressed by:** Bug 1997823\n\n**Description:**\nThe crash occurs during session history reconstruction when restoring a session with multiple tabs containing nested iframes. The assertion triggers because a `SessionHistoryEntry` is being inserted into a linked list while it is already present in a list from a prior incomplete reconstruction.\n\n**Stack Trace:**\n```\n0  xul.dll  mozilla::LinkedListElement<mozilla::URLPreloader::URLEntry>::setPreviousUnsafe  mfbt/LinkedList.h:333\n1  xul.dll  mozilla::LinkedList<mozilla::dom::SessionHistoryEntry>::insertBack  mfbt/LinkedList.h:525\n1  xul.dll  nsSHistory::ReconstructContiguousEntryListFrom  docshell/shistory/nsSHistory.cpp:2516\n2  xul.dll  mozilla::dom::CanonicalBrowsingContext::CreateLoadingSessionHistoryEntryForLoad  docshell/base/CanonicalBrowsingContext.cpp:655\n2  xul.dll  mozilla::net::DocumentLoadListener::Open  netwerk/ipc/DocumentLoadListener.cpp:856\n...\n```\n\n**Root Cause:**\n`ReconstructContiguousEntryListFrom` can be called multiple times for the same `SessionHistoryEntry` during session restore—first during initial restoration and again when a subframe load triggers re-evaluation. This leads to attempts to insert an entry that is already linked in a list, violating the linked list's invariants and causing the assertion crash.\n\n**Affected Conditions:**\n- Session restore involving multiple tabs with nested iframes.\n- When `ReconstructContiguousEntryListFrom` is invoked from `CanonicalBrowsingContext::CreateLoadingSessionHistoryEntryForLoad` during a document load within an iframe, after the parent document's session history has already been partially reconstructed.",
    "original_code_snippets": {
      "docshell/shistory/nsSHistory.cpp": "\nvoid nsSHistory::ReconstructContiguousEntryListFrom(\n    SessionHistoryEntry* aEntry) {\n  RefPtr entryList = EntryListFor(aEntry->DocshellID());\n  entryList->clear();\n  entryList->insertBack(aEntry);\n  for (auto* entry = aEntry;\n       (entry = FindAdjacentContiguousEntryFor(entry, -1));) {\n    entryList->insertFront(entry);\n  }\n  for (auto* entry = aEntry;\n       (entry = FindAdjacentContiguousEntryFor(entry, 1));) {\n    entryList->insertBack(entry);\n  }\n}\n\nvoid nsSHistory::ReconstructContiguousEntryList() {"
    },
    "patch_proposal": "The crash occurs because `ReconstructContiguousEntryListFrom` attempts to insert a `SessionHistoryEntry` that is already in a linked list into another list, triggering an assertion. The root cause is that the function clears the entry list and then inserts entries without checking if they are already in a list. The fix is to ensure entries are removed from any existing list before insertion. The minimal change is to call `remove()` on each entry before inserting it into the new list.\n\nHere is the unified diff patch:\n\n```diff\n--- a/docshell/shistory/nsSHistory.cpp\n+++ b/docshell/shistory/nsSHistory.cpp\n@@ -1,12 +1,15 @@\n void nsSHistory::ReconstructContiguousEntryListFrom(\n     SessionHistoryEntry* aEntry) {\n   RefPtr entryList = EntryListFor(aEntry->DocshellID());\n   entryList->clear();\n+  aEntry->remove();\n   entryList->insertBack(aEntry);\n   for (auto* entry = aEntry;\n        (entry = FindAdjacentContiguousEntryFor(entry, -1));) {\n+    entry->remove();\n     entryList->insertFront(entry);\n   }\n   for (auto* entry = aEntry;\n        (entry = FindAdjacentContiguousEntryFor(entry, 1));) {\n+    entry->remove();\n     entryList->insertBack(entry);\n   }\n }\n```",
    "additional_info_used": null
  }
}